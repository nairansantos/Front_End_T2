{"ast":null,"code":"/**\r\n * @license Angular v16.2.12\r\n * (c) 2010-2022 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\r\n * Operator which completes the Observable when the calling context (component, directive, service,\r\n * etc) is destroyed.\r\n *\r\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\r\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\r\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\r\n *\r\n * @developerPreview\r\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\r\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\r\n *\r\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\r\n *\r\n * `toObservable` must be called in an injection context unless an injector is provided via options.\r\n *\r\n * @developerPreview\r\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked$1(() => subject.error(err));\n      return;\n    }\n    untracked$1(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\r\n * Base URL for the error details page.\r\n *\r\n * Keep this constant in sync across:\r\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\r\n *  - packages/core/src/error_details_base_url.ts\r\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\r\n * URL for the XSS security documentation.\r\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\r\n * Class that represents a runtime error.\r\n * Formats and outputs the error message in a consistent way.\r\n *\r\n * Example:\r\n * ```\r\n *  throw new RuntimeError(\r\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\r\n *    ngDevMode && 'Injector has already been destroyed.');\r\n * ```\r\n *\r\n * Note: the `message` argument contains a descriptive error message as a string in development\r\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\r\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\r\n * logic.\r\n */\nclass RuntimeError extends Error {\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\n/**\r\n * Called to format a runtime error.\r\n * See additional info on the `message` argument type in the `RuntimeError` class description.\r\n */\nfunction formatRuntimeError(code, message) {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n\n/**\r\n * Symbol used to tell `Signal`s apart from other functions.\r\n *\r\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\r\n */\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\n/**\r\n * Checks if the given `value` is a reactive `Signal`.\r\n *\r\n * @developerPreview\r\n */\nfunction isSignal(value) {\n  return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\r\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\r\n * as never equal, and all other primitive values using identity semantics.\r\n *\r\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\r\n * propagate change notification upon explicit mutation without identity change.\r\n *\r\n * @developerPreview\r\n */\nfunction defaultEquals(a, b) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\nconst _global = globalThis;\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0\n  };\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n/**\r\n * This function checks to see if the `ngDevMode` has been set. If yes,\r\n * then we honor it, otherwise we default to dev mode with additional checks.\r\n *\r\n * The idea is that unless we are doing production build where we explicitly\r\n * set `ngDevMode == false` we should be helping the developer by providing\r\n * as much early warning and errors as possible.\r\n *\r\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\r\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\r\n * is defined for the entire instruction set.\r\n *\r\n * When checking `ngDevMode` on toplevel, always init it before referencing it\r\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\r\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\r\n *\r\n * Details on possible values for `ngDevMode` can be found on its docstring.\r\n *\r\n * NOTE:\r\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\r\n */\nfunction initNgDevMode() {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\r\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\r\n *\r\n * Change this via `setActiveConsumer`.\r\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {}\n};\n/**\r\n * Called by implementations when a producer's signal is read.\r\n */\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n  // This producer is the `idx`th dependency of `activeConsumer`.\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    // There's been a change in producers since the last execution of `activeConsumer`.\n    // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n    // replaced with `this`.\n    //\n    // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n    // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n    // to remove it from the stale producer's `liveConsumer`s.\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n      // At this point, the only record of `staleProducer` is the reference at\n      // `activeConsumer.producerNode[idx]` which will be overwritten below.\n    }\n  }\n\n  if (activeConsumer.producerNode[idx] !== node) {\n    // We're a new dependency of the consumer (at `idx`).\n    activeConsumer.producerNode[idx] = node;\n    // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n    // placeholder value.\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\r\n * Ensure this producer's `version` is up-to-date.\r\n */\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    node.dirty = false;\n    return;\n  }\n  node.producerRecomputeValue(node);\n  // After recomputing the value, we're no longer dirty.\n  node.dirty = false;\n}\n/**\r\n * Propagate a dirty notification to live consumers of this producer.\r\n */\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === undefined) {\n    return;\n  }\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\r\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\r\n * based on the current consumer context.\r\n */\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n/**\r\n * Prepare this consumer to run a computation in its reactive context.\r\n *\r\n * Must be called by subclasses which represent reactive computations, before those computations\r\n * begin.\r\n */\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n/**\r\n * Finalize this consumer's state after a reactive computation has run.\r\n *\r\n * Must be called by subclasses which represent reactive computations, after those computations\r\n * have finished.\r\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined || node.producerLastReadVersion === undefined) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n    // which weren't dependencies after the recomputation.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate the producer tracking arrays.\n  // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n  // benchmarking has shown that individual pop operations are faster.\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\n/**\r\n * Determine whether this consumer has any dependencies which have changed since the last time\r\n * they were read.\r\n */\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  // Poll producers for change.\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\r\n * Disconnect this consumer from the graph.\r\n */\nfunction consumerDestroy(node) {\n  assertConsumerNode(node);\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate all the arrays to drop all connection from this node to the graph.\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n  }\n}\n/**\r\n * Add `consumer` as a live consumer of this node.\r\n *\r\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\r\n * a live consumer of all of its current producers.\r\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (node.liveConsumerNode.length === 0) {\n    // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\r\n * Remove the live consumer at `idx`.\r\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n  }\n  if (node.liveConsumerNode.length === 1) {\n    // When removing the last live consumer, we will no longer be live. We need to remove\n    // ourselves from our producers' tracking (which may cause consumer-producers to lose\n    // liveness as well).\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n  // live consumer, this is a no-op.\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  // Truncate the array.\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  // If the index is still valid, then we need to fix the index pointer from the producer to this\n  // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\n\n/**\r\n * Create a computed `Signal` which derives a reactive value from an expression.\r\n *\r\n * @developerPreview\r\n */\nfunction computed(computation, options) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  options?.equal && (node.equal = options.equal);\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  return computed;\n}\n/**\r\n * A dedicated symbol used before a computed value has been calculated for the first time.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\r\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\r\n * is in progress. Used to detect cycles in computation chains.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\r\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\r\n * failed. The thrown error is cached until the computation gets dirty again.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        newValue = node.computation();\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\r\n * If set, called after `WritableSignal`s are updated.\r\n *\r\n * This hook can be used to achieve various effects, such as running effects synchronously as part\r\n * of setting a signal.\r\n */\nlet postSignalSetFn = null;\n/**\r\n * Create a `Signal` that can be set or updated directly.\r\n *\r\n * @developerPreview\r\n */\nfunction signal(initialValue, options) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  options?.equal && (node.equal = options.equal);\n  function signalFn() {\n    producerAccessed(node);\n    return node.value;\n  }\n  signalFn.set = signalSetFn;\n  signalFn.update = signalUpdateFn;\n  signalFn.mutate = signalMutateFn;\n  signalFn.asReadonly = signalAsReadonlyFn;\n  signalFn[SIGNAL] = node;\n  return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    readonlyFn: undefined\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerNotifyConsumers(node);\n  postSignalSetFn?.();\n}\nfunction signalSetFn(newValue) {\n  const node = this[SIGNAL];\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  signalSetFn.call(this, updater(this[SIGNAL].value));\n}\nfunction signalMutateFn(mutator) {\n  const node = this[SIGNAL];\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  // Mutate bypasses equality checks as it's by definition changing the value.\n  mutator(node.value);\n  signalValueChanged(node);\n}\nfunction signalAsReadonlyFn() {\n  const node = this[SIGNAL];\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    readonlyFn[SIGNAL] = node;\n    node.readonlyFn = readonlyFn;\n  }\n  return node.readonlyFn;\n}\n\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n *\r\n * @developerPreview\r\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction watch(fn, schedule, allowSignalWrites) {\n  const node = Object.create(WATCH_NODE);\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n  node.fn = fn;\n  node.schedule = schedule;\n  const registerOnCleanup = cleanupFn => {\n    node.cleanupFn = cleanupFn;\n  };\n  const run = () => {\n    node.dirty = false;\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n    node.hasRun = true;\n    const prevConsumer = consumerBeforeComputation(node);\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn()\n  };\n  return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => {};\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: node => {\n      node.schedule(node.ref);\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN\n  };\n})();\nfunction setAlternateWeakRefImpl(impl) {\n  // TODO: remove this function\n}\nfunction toSignal(source, options) {\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal$1({\n      kind: 0 /* StateKind.NoValue */\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal$1({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    });\n  }\n  untracked(() => {\n    const sub = source.subscribe({\n      next: value => state.set({\n        kind: 1 /* StateKind.Value */,\n        value\n      }),\n      error: error => state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      })\n      // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n      // \"complete\".\n    });\n\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n      throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  });\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed$1(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  });\n}\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };","map":{"version":3,"names":["assertInInjectionContext","inject","DestroyRef","Injector","effect","untracked","untracked$1","signal","signal$1","computed","computed$1","Observable","ReplaySubject","takeUntil","takeUntilDestroyed","destroyRef","destroyed$","observer","unregisterFn","onDestroy","next","bind","source","pipe","toObservable","options","injector","subject","watcher","value","err","error","manualCleanup","get","destroy","complete","asObservable","ERROR_DETAILS_PAGE_BASE_URL","XSS_SECURITY_URL","RuntimeError","Error","constructor","code","message","formatRuntimeError","fullCode","Math","abs","errorMessage","ngDevMode","addPeriodSeparator","match","separator","SIGNAL","Symbol","isSignal","undefined","defaultEquals","a","b","Object","is","_global","globalThis","ngDevModeResetPerfCounters","locationString","location","toString","newCounters","namedConstructors","indexOf","firstCreatePass","tNode","tView","rendererCreateTextNode","rendererSetText","rendererCreateElement","rendererAddEventListener","rendererSetAttribute","rendererRemoveAttribute","rendererSetProperty","rendererSetClassName","rendererAddClass","rendererRemoveClass","rendererSetStyle","rendererRemoveStyle","rendererDestroy","rendererDestroyNode","rendererMoveNode","rendererRemoveNode","rendererAppendChild","rendererInsertBefore","rendererCreateComment","hydratedNodes","hydratedComponents","dehydratedViewsRemoved","dehydratedViewsCleanupRuns","componentsSkippedHydration","allowNgDevModeTrue","initNgDevMode","activeConsumer","inNotificationPhase","setActiveConsumer","consumer","prev","REACTIVE_NODE","version","dirty","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","producerAccessed","node","idx","assertConsumerNode","length","consumerIsLive","staleProducer","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","producerUpdateValueVersion","consumerPollProducersForChange","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","prevConsumer","i","pop","producer","seenVersion","consumerDestroy","indexOfThis","assertProducerNode","push","lastIdx","idxProducer","computation","create","COMPUTED_NODE","equal","ERRORED","UNSET","COMPUTING","oldValue","newValue","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","fn","postSignalSetFn","initialValue","SIGNAL_NODE","signalFn","set","signalSetFn","update","signalUpdateFn","mutate","signalMutateFn","asReadonly","signalAsReadonlyFn","setPostSignalSetFn","readonlyFn","signalValueChanged","updater","call","mutator","nonReactiveReadsFn","watch","schedule","allowSignalWrites","WATCH_NODE","registerOnCleanup","cleanupFn","run","hasRun","NOOP_CLEANUP_FN","ref","notify","cleanup","setAlternateWeakRefImpl","impl","toSignal","requiresCleanup","cleanupRef","state","requireSync","kind","sub","subscribe","unsubscribe","current"],"sources":["C:/Users/55739/Documents/residencia/Front_End_T1/semana19/FEAP011/AddTarefa/node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["/**\r\n * @license Angular v16.2.12\r\n * (c) 2010-2022 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\nimport { takeUntil } from 'rxjs/operators';\r\n\r\n/**\r\n * Operator which completes the Observable when the calling context (component, directive, service,\r\n * etc) is destroyed.\r\n *\r\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\r\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\r\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\r\n *\r\n * @developerPreview\r\n */\r\nfunction takeUntilDestroyed(destroyRef) {\r\n    if (!destroyRef) {\r\n        assertInInjectionContext(takeUntilDestroyed);\r\n        destroyRef = inject(DestroyRef);\r\n    }\r\n    const destroyed$ = new Observable(observer => {\r\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\r\n        return unregisterFn;\r\n    });\r\n    return (source) => {\r\n        return source.pipe(takeUntil(destroyed$));\r\n    };\r\n}\r\n\r\n/**\r\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\r\n *\r\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\r\n *\r\n * `toObservable` must be called in an injection context unless an injector is provided via options.\r\n *\r\n * @developerPreview\r\n */\r\nfunction toObservable(source, options) {\r\n    !options?.injector && assertInInjectionContext(toObservable);\r\n    const injector = options?.injector ?? inject(Injector);\r\n    const subject = new ReplaySubject(1);\r\n    const watcher = effect(() => {\r\n        let value;\r\n        try {\r\n            value = source();\r\n        }\r\n        catch (err) {\r\n            untracked$1(() => subject.error(err));\r\n            return;\r\n        }\r\n        untracked$1(() => subject.next(value));\r\n    }, { injector, manualCleanup: true });\r\n    injector.get(DestroyRef).onDestroy(() => {\r\n        watcher.destroy();\r\n        subject.complete();\r\n    });\r\n    return subject.asObservable();\r\n}\r\n\r\n/**\r\n * Base URL for the error details page.\r\n *\r\n * Keep this constant in sync across:\r\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\r\n *  - packages/core/src/error_details_base_url.ts\r\n */\r\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\r\n/**\r\n * URL for the XSS security documentation.\r\n */\r\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\r\n\r\n/**\r\n * Class that represents a runtime error.\r\n * Formats and outputs the error message in a consistent way.\r\n *\r\n * Example:\r\n * ```\r\n *  throw new RuntimeError(\r\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\r\n *    ngDevMode && 'Injector has already been destroyed.');\r\n * ```\r\n *\r\n * Note: the `message` argument contains a descriptive error message as a string in development\r\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\r\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\r\n * logic.\r\n */\r\nclass RuntimeError extends Error {\r\n    constructor(code, message) {\r\n        super(formatRuntimeError(code, message));\r\n        this.code = code;\r\n    }\r\n}\r\n/**\r\n * Called to format a runtime error.\r\n * See additional info on the `message` argument type in the `RuntimeError` class description.\r\n */\r\nfunction formatRuntimeError(code, message) {\r\n    // Error code might be a negative number, which is a special marker that instructs the logic to\r\n    // generate a link to the error details page on angular.io.\r\n    // We also prepend `0` to non-compile-time errors.\r\n    const fullCode = `NG0${Math.abs(code)}`;\r\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\r\n    if (ngDevMode && code < 0) {\r\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\r\n        const separator = addPeriodSeparator ? '.' : '';\r\n        errorMessage =\r\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\r\n    }\r\n    return errorMessage;\r\n}\r\n\r\n/**\r\n * Symbol used to tell `Signal`s apart from other functions.\r\n *\r\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\r\n */\r\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\r\n/**\r\n * Checks if the given `value` is a reactive `Signal`.\r\n *\r\n * @developerPreview\r\n */\r\nfunction isSignal(value) {\r\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\r\n}\r\n/**\r\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\r\n * as never equal, and all other primitive values using identity semantics.\r\n *\r\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\r\n * propagate change notification upon explicit mutation without identity change.\r\n *\r\n * @developerPreview\r\n */\r\nfunction defaultEquals(a, b) {\r\n    // `Object.is` compares two values using identity semantics which is desired behavior for\r\n    // primitive values. If `Object.is` determines two values to be equal we need to make sure that\r\n    // those don't represent objects (we want to make sure that 2 objects are always considered\r\n    // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\r\n    // as objects (`typeof null === 'object'`).\r\n    return (a === null || typeof a !== 'object') && Object.is(a, b);\r\n}\r\n\r\nconst _global = globalThis;\r\n\r\nfunction ngDevModeResetPerfCounters() {\r\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\r\n    const newCounters = {\r\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\r\n        firstCreatePass: 0,\r\n        tNode: 0,\r\n        tView: 0,\r\n        rendererCreateTextNode: 0,\r\n        rendererSetText: 0,\r\n        rendererCreateElement: 0,\r\n        rendererAddEventListener: 0,\r\n        rendererSetAttribute: 0,\r\n        rendererRemoveAttribute: 0,\r\n        rendererSetProperty: 0,\r\n        rendererSetClassName: 0,\r\n        rendererAddClass: 0,\r\n        rendererRemoveClass: 0,\r\n        rendererSetStyle: 0,\r\n        rendererRemoveStyle: 0,\r\n        rendererDestroy: 0,\r\n        rendererDestroyNode: 0,\r\n        rendererMoveNode: 0,\r\n        rendererRemoveNode: 0,\r\n        rendererAppendChild: 0,\r\n        rendererInsertBefore: 0,\r\n        rendererCreateComment: 0,\r\n        hydratedNodes: 0,\r\n        hydratedComponents: 0,\r\n        dehydratedViewsRemoved: 0,\r\n        dehydratedViewsCleanupRuns: 0,\r\n        componentsSkippedHydration: 0,\r\n    };\r\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\r\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\r\n    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\r\n    return newCounters;\r\n}\r\n/**\r\n * This function checks to see if the `ngDevMode` has been set. If yes,\r\n * then we honor it, otherwise we default to dev mode with additional checks.\r\n *\r\n * The idea is that unless we are doing production build where we explicitly\r\n * set `ngDevMode == false` we should be helping the developer by providing\r\n * as much early warning and errors as possible.\r\n *\r\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\r\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\r\n * is defined for the entire instruction set.\r\n *\r\n * When checking `ngDevMode` on toplevel, always init it before referencing it\r\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\r\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\r\n *\r\n * Details on possible values for `ngDevMode` can be found on its docstring.\r\n *\r\n * NOTE:\r\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\r\n */\r\nfunction initNgDevMode() {\r\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\r\n    // reset the counters.\r\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\r\n    // yet.\r\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n        if (typeof ngDevMode !== 'object') {\r\n            ngDevModeResetPerfCounters();\r\n        }\r\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\r\n    }\r\n    return false;\r\n}\r\n\r\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\r\n/**\r\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\r\n *\r\n * Change this via `setActiveConsumer`.\r\n */\r\nlet activeConsumer = null;\r\nlet inNotificationPhase = false;\r\nfunction setActiveConsumer(consumer) {\r\n    const prev = activeConsumer;\r\n    activeConsumer = consumer;\r\n    return prev;\r\n}\r\nconst REACTIVE_NODE = {\r\n    version: 0,\r\n    dirty: false,\r\n    producerNode: undefined,\r\n    producerLastReadVersion: undefined,\r\n    producerIndexOfThis: undefined,\r\n    nextProducerIndex: 0,\r\n    liveConsumerNode: undefined,\r\n    liveConsumerIndexOfThis: undefined,\r\n    consumerAllowSignalWrites: false,\r\n    consumerIsAlwaysLive: false,\r\n    producerMustRecompute: () => false,\r\n    producerRecomputeValue: () => { },\r\n    consumerMarkedDirty: () => { },\r\n};\r\n/**\r\n * Called by implementations when a producer's signal is read.\r\n */\r\nfunction producerAccessed(node) {\r\n    if (inNotificationPhase) {\r\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ?\r\n            `Assertion error: signal read during notification phase` :\r\n            '');\r\n    }\r\n    if (activeConsumer === null) {\r\n        // Accessed outside of a reactive context, so nothing to record.\r\n        return;\r\n    }\r\n    // This producer is the `idx`th dependency of `activeConsumer`.\r\n    const idx = activeConsumer.nextProducerIndex++;\r\n    assertConsumerNode(activeConsumer);\r\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\r\n        // There's been a change in producers since the last execution of `activeConsumer`.\r\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\r\n        // replaced with `this`.\r\n        //\r\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\r\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\r\n        // to remove it from the stale producer's `liveConsumer`s.\r\n        if (consumerIsLive(activeConsumer)) {\r\n            const staleProducer = activeConsumer.producerNode[idx];\r\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\r\n            // At this point, the only record of `staleProducer` is the reference at\r\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\r\n        }\r\n    }\r\n    if (activeConsumer.producerNode[idx] !== node) {\r\n        // We're a new dependency of the consumer (at `idx`).\r\n        activeConsumer.producerNode[idx] = node;\r\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\r\n        // placeholder value.\r\n        activeConsumer.producerIndexOfThis[idx] =\r\n            consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\r\n    }\r\n    activeConsumer.producerLastReadVersion[idx] = node.version;\r\n}\r\n/**\r\n * Ensure this producer's `version` is up-to-date.\r\n */\r\nfunction producerUpdateValueVersion(node) {\r\n    if (consumerIsLive(node) && !node.dirty) {\r\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\r\n        // is guaranteed to be up-to-date.\r\n        return;\r\n    }\r\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\r\n        // None of our producers report a change since the last time they were read, so no\r\n        // recomputation of our value is necessary, and we can consider ourselves clean.\r\n        node.dirty = false;\r\n        return;\r\n    }\r\n    node.producerRecomputeValue(node);\r\n    // After recomputing the value, we're no longer dirty.\r\n    node.dirty = false;\r\n}\r\n/**\r\n * Propagate a dirty notification to live consumers of this producer.\r\n */\r\nfunction producerNotifyConsumers(node) {\r\n    if (node.liveConsumerNode === undefined) {\r\n        return;\r\n    }\r\n    // Prevent signal reads when we're updating the graph\r\n    const prev = inNotificationPhase;\r\n    inNotificationPhase = true;\r\n    try {\r\n        for (const consumer of node.liveConsumerNode) {\r\n            if (!consumer.dirty) {\r\n                consumerMarkDirty(consumer);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        inNotificationPhase = prev;\r\n    }\r\n}\r\n/**\r\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\r\n * based on the current consumer context.\r\n */\r\nfunction producerUpdatesAllowed() {\r\n    return activeConsumer?.consumerAllowSignalWrites !== false;\r\n}\r\nfunction consumerMarkDirty(node) {\r\n    node.dirty = true;\r\n    producerNotifyConsumers(node);\r\n    node.consumerMarkedDirty?.(node);\r\n}\r\n/**\r\n * Prepare this consumer to run a computation in its reactive context.\r\n *\r\n * Must be called by subclasses which represent reactive computations, before those computations\r\n * begin.\r\n */\r\nfunction consumerBeforeComputation(node) {\r\n    node && (node.nextProducerIndex = 0);\r\n    return setActiveConsumer(node);\r\n}\r\n/**\r\n * Finalize this consumer's state after a reactive computation has run.\r\n *\r\n * Must be called by subclasses which represent reactive computations, after those computations\r\n * have finished.\r\n */\r\nfunction consumerAfterComputation(node, prevConsumer) {\r\n    setActiveConsumer(prevConsumer);\r\n    if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined ||\r\n        node.producerLastReadVersion === undefined) {\r\n        return;\r\n    }\r\n    if (consumerIsLive(node)) {\r\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\r\n        // which weren't dependencies after the recomputation.\r\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\r\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\r\n        }\r\n    }\r\n    // Truncate the producer tracking arrays.\r\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\r\n    // benchmarking has shown that individual pop operations are faster.\r\n    while (node.producerNode.length > node.nextProducerIndex) {\r\n        node.producerNode.pop();\r\n        node.producerLastReadVersion.pop();\r\n        node.producerIndexOfThis.pop();\r\n    }\r\n}\r\n/**\r\n * Determine whether this consumer has any dependencies which have changed since the last time\r\n * they were read.\r\n */\r\nfunction consumerPollProducersForChange(node) {\r\n    assertConsumerNode(node);\r\n    // Poll producers for change.\r\n    for (let i = 0; i < node.producerNode.length; i++) {\r\n        const producer = node.producerNode[i];\r\n        const seenVersion = node.producerLastReadVersion[i];\r\n        // First check the versions. A mismatch means that the producer's value is known to have\r\n        // changed since the last time we read it.\r\n        if (seenVersion !== producer.version) {\r\n            return true;\r\n        }\r\n        // The producer's version is the same as the last time we read it, but it might itself be\r\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\r\n        producerUpdateValueVersion(producer);\r\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\r\n        // versions still match then it has not changed since the last time we read it.\r\n        if (seenVersion !== producer.version) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Disconnect this consumer from the graph.\r\n */\r\nfunction consumerDestroy(node) {\r\n    assertConsumerNode(node);\r\n    if (consumerIsLive(node)) {\r\n        // Drop all connections from the graph to this node.\r\n        for (let i = 0; i < node.producerNode.length; i++) {\r\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\r\n        }\r\n    }\r\n    // Truncate all the arrays to drop all connection from this node to the graph.\r\n    node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length =\r\n        0;\r\n    if (node.liveConsumerNode) {\r\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\r\n    }\r\n}\r\n/**\r\n * Add `consumer` as a live consumer of this node.\r\n *\r\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\r\n * a live consumer of all of its current producers.\r\n */\r\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\r\n    assertProducerNode(node);\r\n    assertConsumerNode(node);\r\n    if (node.liveConsumerNode.length === 0) {\r\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\r\n        for (let i = 0; i < node.producerNode.length; i++) {\r\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\r\n        }\r\n    }\r\n    node.liveConsumerIndexOfThis.push(indexOfThis);\r\n    return node.liveConsumerNode.push(consumer) - 1;\r\n}\r\n/**\r\n * Remove the live consumer at `idx`.\r\n */\r\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\r\n    assertProducerNode(node);\r\n    assertConsumerNode(node);\r\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\r\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\r\n    }\r\n    if (node.liveConsumerNode.length === 1) {\r\n        // When removing the last live consumer, we will no longer be live. We need to remove\r\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\r\n        // liveness as well).\r\n        for (let i = 0; i < node.producerNode.length; i++) {\r\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\r\n        }\r\n    }\r\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\r\n    // live consumer, this is a no-op.\r\n    const lastIdx = node.liveConsumerNode.length - 1;\r\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\r\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\r\n    // Truncate the array.\r\n    node.liveConsumerNode.length--;\r\n    node.liveConsumerIndexOfThis.length--;\r\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\r\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\r\n    if (idx < node.liveConsumerNode.length) {\r\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\r\n        const consumer = node.liveConsumerNode[idx];\r\n        assertConsumerNode(consumer);\r\n        consumer.producerIndexOfThis[idxProducer] = idx;\r\n    }\r\n}\r\nfunction consumerIsLive(node) {\r\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\r\n}\r\nfunction assertConsumerNode(node) {\r\n    node.producerNode ??= [];\r\n    node.producerIndexOfThis ??= [];\r\n    node.producerLastReadVersion ??= [];\r\n}\r\nfunction assertProducerNode(node) {\r\n    node.liveConsumerNode ??= [];\r\n    node.liveConsumerIndexOfThis ??= [];\r\n}\r\n\r\n/**\r\n * Create a computed `Signal` which derives a reactive value from an expression.\r\n *\r\n * @developerPreview\r\n */\r\nfunction computed(computation, options) {\r\n    const node = Object.create(COMPUTED_NODE);\r\n    node.computation = computation;\r\n    options?.equal && (node.equal = options.equal);\r\n    const computed = () => {\r\n        // Check if the value needs updating before returning it.\r\n        producerUpdateValueVersion(node);\r\n        // Record that someone looked at this signal.\r\n        producerAccessed(node);\r\n        if (node.value === ERRORED) {\r\n            throw node.error;\r\n        }\r\n        return node.value;\r\n    };\r\n    computed[SIGNAL] = node;\r\n    return computed;\r\n}\r\n/**\r\n * A dedicated symbol used before a computed value has been calculated for the first time.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\r\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\r\n/**\r\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\r\n * is in progress. Used to detect cycles in computation chains.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\r\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\r\n/**\r\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\r\n * failed. The thrown error is cached until the computation gets dirty again.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\r\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        value: UNSET,\r\n        dirty: true,\r\n        error: null,\r\n        equal: defaultEquals,\r\n        producerMustRecompute(node) {\r\n            // Force a recomputation if there's no current value, or if the current value is in the\r\n            // process of being calculated (which should throw an error).\r\n            return node.value === UNSET || node.value === COMPUTING;\r\n        },\r\n        producerRecomputeValue(node) {\r\n            if (node.value === COMPUTING) {\r\n                // Our computation somehow led to a cyclic read of itself.\r\n                throw new Error('Detected cycle in computations.');\r\n            }\r\n            const oldValue = node.value;\r\n            node.value = COMPUTING;\r\n            const prevConsumer = consumerBeforeComputation(node);\r\n            let newValue;\r\n            try {\r\n                newValue = node.computation();\r\n            }\r\n            catch (err) {\r\n                newValue = ERRORED;\r\n                node.error = err;\r\n            }\r\n            finally {\r\n                consumerAfterComputation(node, prevConsumer);\r\n            }\r\n            if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\r\n                node.equal(oldValue, newValue)) {\r\n                // No change to `valueVersion` - old and new values are\r\n                // semantically equivalent.\r\n                node.value = oldValue;\r\n                return;\r\n            }\r\n            node.value = newValue;\r\n            node.version++;\r\n        },\r\n    };\r\n})();\r\n\r\nfunction defaultThrowError() {\r\n    throw new Error();\r\n}\r\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\r\nfunction throwInvalidWriteToSignalError() {\r\n    throwInvalidWriteToSignalErrorFn();\r\n}\r\nfunction setThrowInvalidWriteToSignalError(fn) {\r\n    throwInvalidWriteToSignalErrorFn = fn;\r\n}\r\n\r\n/**\r\n * If set, called after `WritableSignal`s are updated.\r\n *\r\n * This hook can be used to achieve various effects, such as running effects synchronously as part\r\n * of setting a signal.\r\n */\r\nlet postSignalSetFn = null;\r\n/**\r\n * Create a `Signal` that can be set or updated directly.\r\n *\r\n * @developerPreview\r\n */\r\nfunction signal(initialValue, options) {\r\n    const node = Object.create(SIGNAL_NODE);\r\n    node.value = initialValue;\r\n    options?.equal && (node.equal = options.equal);\r\n    function signalFn() {\r\n        producerAccessed(node);\r\n        return node.value;\r\n    }\r\n    signalFn.set = signalSetFn;\r\n    signalFn.update = signalUpdateFn;\r\n    signalFn.mutate = signalMutateFn;\r\n    signalFn.asReadonly = signalAsReadonlyFn;\r\n    signalFn[SIGNAL] = node;\r\n    return signalFn;\r\n}\r\nfunction setPostSignalSetFn(fn) {\r\n    const prev = postSignalSetFn;\r\n    postSignalSetFn = fn;\r\n    return prev;\r\n}\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        equal: defaultEquals,\r\n        readonlyFn: undefined,\r\n    };\r\n})();\r\nfunction signalValueChanged(node) {\r\n    node.version++;\r\n    producerNotifyConsumers(node);\r\n    postSignalSetFn?.();\r\n}\r\nfunction signalSetFn(newValue) {\r\n    const node = this[SIGNAL];\r\n    if (!producerUpdatesAllowed()) {\r\n        throwInvalidWriteToSignalError();\r\n    }\r\n    if (!node.equal(node.value, newValue)) {\r\n        node.value = newValue;\r\n        signalValueChanged(node);\r\n    }\r\n}\r\nfunction signalUpdateFn(updater) {\r\n    if (!producerUpdatesAllowed()) {\r\n        throwInvalidWriteToSignalError();\r\n    }\r\n    signalSetFn.call(this, updater(this[SIGNAL].value));\r\n}\r\nfunction signalMutateFn(mutator) {\r\n    const node = this[SIGNAL];\r\n    if (!producerUpdatesAllowed()) {\r\n        throwInvalidWriteToSignalError();\r\n    }\r\n    // Mutate bypasses equality checks as it's by definition changing the value.\r\n    mutator(node.value);\r\n    signalValueChanged(node);\r\n}\r\nfunction signalAsReadonlyFn() {\r\n    const node = this[SIGNAL];\r\n    if (node.readonlyFn === undefined) {\r\n        const readonlyFn = () => this();\r\n        readonlyFn[SIGNAL] = node;\r\n        node.readonlyFn = readonlyFn;\r\n    }\r\n    return node.readonlyFn;\r\n}\r\n\r\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n *\r\n * @developerPreview\r\n */\r\nfunction untracked(nonReactiveReadsFn) {\r\n    const prevConsumer = setActiveConsumer(null);\r\n    // We are not trying to catch any particular errors here, just making sure that the consumers\r\n    // stack is restored in case of errors.\r\n    try {\r\n        return nonReactiveReadsFn();\r\n    }\r\n    finally {\r\n        setActiveConsumer(prevConsumer);\r\n    }\r\n}\r\n\r\nfunction watch(fn, schedule, allowSignalWrites) {\r\n    const node = Object.create(WATCH_NODE);\r\n    if (allowSignalWrites) {\r\n        node.consumerAllowSignalWrites = true;\r\n    }\r\n    node.fn = fn;\r\n    node.schedule = schedule;\r\n    const registerOnCleanup = (cleanupFn) => {\r\n        node.cleanupFn = cleanupFn;\r\n    };\r\n    const run = () => {\r\n        node.dirty = false;\r\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\r\n            return;\r\n        }\r\n        node.hasRun = true;\r\n        const prevConsumer = consumerBeforeComputation(node);\r\n        try {\r\n            node.cleanupFn();\r\n            node.cleanupFn = NOOP_CLEANUP_FN;\r\n            node.fn(registerOnCleanup);\r\n        }\r\n        finally {\r\n            consumerAfterComputation(node, prevConsumer);\r\n        }\r\n    };\r\n    node.ref = {\r\n        notify: () => consumerMarkDirty(node),\r\n        run,\r\n        cleanup: () => node.cleanupFn(),\r\n    };\r\n    return node.ref;\r\n}\r\nconst NOOP_CLEANUP_FN = () => { };\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst WATCH_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        consumerIsAlwaysLive: true,\r\n        consumerAllowSignalWrites: false,\r\n        consumerMarkedDirty: (node) => {\r\n            node.schedule(node.ref);\r\n        },\r\n        hasRun: false,\r\n        cleanupFn: NOOP_CLEANUP_FN,\r\n    };\r\n})();\r\n\r\nfunction setAlternateWeakRefImpl(impl) {\r\n    // TODO: remove this function\r\n}\r\n\r\nfunction toSignal(source, options) {\r\n    const requiresCleanup = !options?.manualCleanup;\r\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\r\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\r\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\r\n    // the same - the returned signal gives values of type `T`.\r\n    let state;\r\n    if (options?.requireSync) {\r\n        // Initially the signal is in a `NoValue` state.\r\n        state = signal$1({ kind: 0 /* StateKind.NoValue */ });\r\n    }\r\n    else {\r\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\r\n        state = signal$1({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\r\n    }\r\n    untracked(() => {\r\n        const sub = source.subscribe({\r\n            next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\r\n            error: error => state.set({ kind: 2 /* StateKind.Error */, error }),\r\n            // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\r\n            // \"complete\".\r\n        });\r\n        if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\r\n            throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n        }\r\n        // Unsubscribe when the current context is destroyed, if requested.\r\n        cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\r\n    });\r\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\r\n    // to either values or errors.\r\n    return computed$1(() => {\r\n        const current = state();\r\n        switch (current.kind) {\r\n            case 1 /* StateKind.Value */:\r\n                return current.value;\r\n            case 2 /* StateKind.Error */:\r\n                throw current.error;\r\n            case 0 /* StateKind.NoValue */:\r\n                // This shouldn't really happen because the error is thrown on creation.\r\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\r\n                throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { takeUntilDestroyed, toObservable, toSignal };\r\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}